# Part of this code is based on https://github.com/Walter0807/MotionBERT
import torch
import torch.nn as nn
import math
import warnings
import numpy as np
import einops

import torch
import torch.nn as nn
import torch.nn.functional as F
from pytorch3d.transforms import matrix_to_rotation_6d, rotation_6d_to_matrix
from timm.models.vision_transformer import Mlp

from .positional_encoding import PositionEmbeddingSine
from .rotary_embedding import ROPE
from ..utils import GlobalTrajHelper


def drop_path(x, drop_prob: float = 0.0, training: bool = False):
    """Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).
    This is the same as the DropConnect impl I created for EfficientNet, etc networks, however,
    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...
    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ... I've opted for
    changing the layer and argument names to 'drop path' rather than mix DropConnect as a layer name and use
    'survival rate' as the argument.
    """
    if drop_prob == 0.0 or not training:
        return x
    keep_prob = 1 - drop_prob
    shape = (x.shape[0],) + (1,) * (
        x.ndim - 1
    )  # work with diff dim tensors, not just 2D ConvNets
    random_tensor = keep_prob + torch.rand(shape, dtype=x.dtype, device=x.device)
    random_tensor.floor_()  # binarize
    output = x.div(keep_prob) * random_tensor
    return output


class DropPath(nn.Module):
    """Drop paths (Stochastic Depth) per sample  (when applied in main path of residual blocks)."""

    def __init__(self, drop_prob=None):
        super(DropPath, self).__init__()
        self.drop_prob = drop_prob

    def forward(self, x):
        return drop_path(x, self.drop_prob, self.training)


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn(
            "mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
            "The distribution of values may be incorrect.",
            stacklevel=2,
        )

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.0))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def trunc_normal_(tensor, mean=0.0, std=1.0, a=-2.0, b=2.0):
    # type: (torch.Tensor, float, float, float, float) -> torch.Tensor
    r"""Fills the input Tensor with values drawn from a truncated
    normal distribution. The values are effectively drawn from the
    normal distribution :math:`\mathcal{N}(\text{mean}, \text{std}^2)`
    with values outside :math:`[a, b]` redrawn until they are within
    the bounds. The method used for generating the random values works
    best when :math:`a \leq \text{mean} \leq b`.
    Args:
        tensor: an n-dimensional `torch.Tensor`
        mean: the mean of the normal distribution
        std: the standard deviation of the normal distribution
        a: the minimum cutoff value
        b: the maximum cutoff value
    Examples:
        >>> w = torch.empty(3, 5)
        >>> nn.init.trunc_normal_(w)
    """
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


class MLP(nn.Module):
    def __init__(
        self,
        in_features,
        hidden_features=None,
        out_features=None,
        act_layer=nn.GELU,
        drop=0.0,
    ):
        super().__init__()
        out_features = out_features or in_features
        hidden_features = hidden_features or in_features
        self.fc1 = nn.Linear(in_features, hidden_features)
        self.act = act_layer()
        self.fc2 = nn.Linear(hidden_features, out_features)
        self.drop = nn.Dropout(drop)

    def forward(self, x):
        x = self.fc1(x)
        x = self.act(x)
        x = self.drop(x)
        x = self.fc2(x)
        x = self.drop(x)
        return x


class Attention(nn.Module):
    def __init__(
        self,
        cfg,
        dim,
        st_mode="temporal",
    ):
        super().__init__()

        num_heads = cfg.num_heads
        qkv_bias = cfg.get("qkv_bias", True)
        qk_scale = cfg.get("qk_scale", None)
        proj_drop = cfg.get("drop_rate", 0.0)
        attn_drop = cfg.get("attn_drop_rate", 0.0)

        self.num_heads = num_heads
        head_dim = dim // num_heads
        self.head_dim = head_dim
        self.scale = qk_scale or head_dim**-0.5

        self.attn_drop = nn.Dropout(attn_drop)
        self.proj = nn.Linear(dim, dim)
        self.mode = st_mode
        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)
        self.proj_drop = nn.Dropout(proj_drop)

        if self.mode == "temporal":
            self.rope = ROPE(head_dim)
            self.attn_len = cfg.get("attn_len", 60)

    def forward(self, x):
        B, F, J, C = x.shape

        if self.mode == "temporal":
            x = x.permute(0, 2, 1, 3).reshape(B * J, F, C)
            qkv = (
                self.qkv(x)
                .reshape(-1, F, 3, self.num_heads, C // self.num_heads)
                .permute(2, 0, 3, 1, 4)
            )
            q, k, v = (
                qkv[0],
                qkv[1],
                qkv[2],
            )  # make torchscript happy (cannot use tensor as tuple)
            
            # Apply RoPE to queries and keys
            q = self.rope.rotate_queries_or_keys(q)  # B*J, N, F, C
            k = self.rope.rotate_queries_or_keys(k)  # B*J, N, F, C
            
            x = self.forward_attention(q, k, v)
            x = x.reshape(B, J, F, C).permute(0, 2, 1, 3)
        elif self.mode == "spatial":
            x = x.reshape(B * F, J, C)
            qkv = (
                self.qkv(x)
                .reshape(-1, J, 3, self.num_heads, C // self.num_heads)
                .permute(2, 0, 3, 1, 4)
            )
            q, k, v = (
                qkv[0],
                qkv[1],
                qkv[2],
            )  # make torchscript happy (cannot use tensor as tuple)
            x = self.forward_attention(q, k, v)
            x = x.reshape(B, F, J, C)
        else:
            raise NotImplementedError(self.mode)
        x = self.proj(x)
        x = self.proj_drop(x)
        return x

    def forward_attention(self, q, k, v):
        B, H, N, C = q.shape
        attn = (q @ k.transpose(-2, -1)) * self.scale

        if self.mode == "temporal":
            # Create attention mask based on attn_len
            # Each frame i can only attend to frames [i-attn_len, i+attn_len]
            attn_mask = torch.zeros(N, N, dtype=torch.bool, device=q.device)
            for i in range(N):
                start = max(0, i - self.attn_len)
                end = min(N, i + self.attn_len + 1)
                attn_mask[i, start:end] = True
            
            attn_mask = attn_mask.reshape(1, 1, N, N).expand(B, H, -1, -1)
            attn = attn.masked_fill(attn_mask.logical_not(), float("-inf"))

        attn = attn.softmax(dim=-1)

        attn = self.attn_drop(attn)

        x = attn @ v
        x = x.transpose(1, 2).reshape(B, N, C * self.num_heads)
        return x


class Block(nn.Module):

    def __init__(
        self,
        cfg,
        # dimensions
        dim,
        # other configs
        drop_path=0.0,
        mlp_out_ratio=1.0,
        act_layer=nn.GELU,
        norm_layer=nn.LayerNorm,
        st_mode="stage_st",
        att_fuse=False,
    ):
        super().__init__()
        self.cfg = cfg
        mlp_ratio = cfg.get("mlp_ratio", 4)
        drop = cfg.get("drop_rate", 0.0)

        self.st_mode = st_mode

        self.norm1_s = norm_layer(dim)
        self.norm1_t = norm_layer(dim)
        self.attn_s = Attention(
            cfg,
            dim,
            st_mode="spatial",
        )
        self.attn_t = Attention(
            cfg,
            dim,
            st_mode="temporal",
        )

        # NOTE: drop path for stochastic depth, we shall see if this is better than dropout here
        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()
        self.norm2_s = norm_layer(dim)
        self.norm2_t = norm_layer(dim)
        mlp_hidden_dim = int(dim * mlp_ratio)
        mlp_out_dim = int(dim * mlp_out_ratio)
        self.mlp_s = MLP(
            in_features=dim,
            hidden_features=mlp_hidden_dim,
            out_features=mlp_out_dim,
            act_layer=act_layer,
            drop=drop,
        )
        self.mlp_t = MLP(
            in_features=dim,
            hidden_features=mlp_hidden_dim,
            out_features=mlp_out_dim,
            act_layer=act_layer,
            drop=drop,
        )
        self.att_fuse = att_fuse
        if self.att_fuse:
            self.ts_attn = nn.Linear(dim * 2, dim * 2)

    def forward(self, x):
        if self.st_mode == "stage_st":
            x = x + self.drop_path(self.attn_s(self.norm1_s(x)))
            x = x + self.drop_path(self.mlp_s(self.norm2_s(x)))
            x = x + self.drop_path(self.attn_t(self.norm1_t(x)))
            x = x + self.drop_path(self.mlp_t(self.norm2_t(x)))
        elif self.st_mode == "stage_ts":
            x = x + self.drop_path(self.attn_t(self.norm1_t(x)))
            x = x + self.drop_path(self.mlp_t(self.norm2_t(x)))
            x = x + self.drop_path(self.attn_s(self.norm1_s(x)))
            x = x + self.drop_path(self.mlp_s(self.norm2_s(x)))
        elif self.st_mode == "stage_para":
            x_t = x + self.drop_path(self.attn_t(self.norm1_t(x)))
            x_t = x_t + self.drop_path(self.mlp_t(self.norm2_t(x_t)))
            x_s = x + self.drop_path(self.attn_s(self.norm1_s(x)))
            x_s = x_s + self.drop_path(self.mlp_s(self.norm2_s(x_s)))
            if self.att_fuse:
                #             x_s, x_t: [B, F, J, C]
                B, F, J, C = x_s.shape
                alpha = torch.cat([x_s, x_t], dim=-1)
                alpha = self.ts_attn(alpha).reshape(B, F, J, C, 2)
                alpha = alpha.softmax(dim=-1)
                x = x_t * alpha[..., 1] + x_s * alpha[..., 0]
            else:
                x = (x_s + x_t) * 0.5
        else:
            raise NotImplementedError(self.st_mode)
        return x

class SpatialFormer(nn.Module):
    def __init__(self, cfg, dim_feat, depth):
        super().__init__()
        self.cfg = cfg
        self.dim_feat = dim_feat
        self.depth = depth

        # Use PyTorch's TransformerEncoderLayer for spatial attention only
        encoder_layer = nn.TransformerEncoderLayer(
            d_model=dim_feat,
            nhead=cfg.num_heads,
            dim_feedforward=int(dim_feat * cfg.get("mlp_ratio", 4)),
            dropout=cfg.get("drop_rate", 0.0),
            activation="gelu",
            batch_first=True,
        )
        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers=depth)

    def forward(self, x):
        # x shape: (B, F, J, C)
        B, F, J, C = x.shape
        
        # Reshape to (B*F, J, C) to process each frame independently
        x = x.reshape(B * F, J, C)
        
        # Apply spatial attention using TransformerEncoder
        x = self.transformer(x)
        
        # Reshape back to (B, F, J, C)
        x = x.reshape(B, F, J, C)
        return x

class DSTFormer(nn.Module):
    def __init__(self, cfg, dim_feat, depth):
        super().__init__()
        self.cfg = cfg

        self.dim_feat = dim_feat
        self.depth = depth

        self.num_heads = cfg.num_heads
        self.mlp_ratio = cfg.mlp_ratio
        self.qkv_bias = cfg.get("qkv_bias", True)
        self.qk_scale = cfg.get("qk_scale", None)
        self.drop_rate = cfg.get("drop_rate", 0.0)
        self.attn_drop_rate = cfg.get("attn_drop_rate", 0.0)

        self.att_fuse = cfg.get("att_fuse", True)

        self.blocks_st = nn.ModuleList(
            [
                Block(
                    self.cfg,
                    dim=self.dim_feat,
                    st_mode="stage_st",
                )
                for i in range(self.depth)
            ]
        )
        self.blocks_ts = nn.ModuleList(
            [
                Block(
                    self.cfg,
                    dim=self.dim_feat,
                    st_mode="stage_ts",
                )
                for i in range(self.depth)
            ]
        )

        if self.att_fuse:
            self.ts_attn = nn.ModuleList(
                [nn.Linear(self.dim_feat * 2, 2) for i in range(self.depth)]
            )
            for i in range(self.depth):
                self.ts_attn[i].weight.data.fill_(0)
                self.ts_attn[i].bias.data.fill_(0.5)

    def forward(self, x):
        for idx, (blk_st, blk_ts) in enumerate(zip(self.blocks_st, self.blocks_ts)):
            x_st = blk_st(x)
            x_ts = blk_ts(x)
            if self.att_fuse:
                att = self.ts_attn[idx]
                alpha = torch.cat([x_st, x_ts], dim=-1)
                alpha = att(alpha)
                alpha = alpha.softmax(dim=-1)
                x = x_st * alpha[..., 0:1] + x_ts * alpha[..., 1:2]
            else:
                x = (x_st + x_ts) * 0.5
        return x

class VMDSTFormer(nn.Module):
    """
    DSTFormer model designed for video motion reconstruction

    Motion 2D encoder + per-frame image 1D encoder + 2D decoder

    input:
        - tokens: [B, F, J, C]
    output:
        - logits: [B, N, F, J]

    B: batch size
    F: sequence length, default 144
    J: number of body parts, default 87
    C: token dimension
    N: number of tokens
    """

    def __init__(self, cfg):
        super().__init__()

        self.cfg = cfg

        self.task = cfg.task

        # read configs
        self.dim_in = cfg.dim_in
        self.dim_out = cfg.dim_out
        self.dim_feat = cfg.dim_feat

        # backbone feature dimension
        self.dim_backbone_feat = cfg.dim_backbone_feat

        # canonical space trajectory dimension
        self.dim_cano_traj = cfg.get(
            "dim_cano_traj", 9
        )  # (6D rotation + 3D translation) * (absolute + relative)
        # camera space trajectory dimension
        self.dim_cam_traj = cfg.get(
            "dim_cam_traj", 6 + 3
        )  # 6D rotation + 3D translation
        self.dim_contact = cfg.get("dim_contact", 6)  # number of contact points

        # depth of transformer
        self.mdepth = cfg.mdepth
        self.idepth = cfg.idepth
        self.ddepth = cfg.ddepth

        self.num_frames = cfg.get("num_frames", 60)
        self.num_tokens = cfg.num_tokens

        self.learnable_pe = cfg.get("learnable_pe", True)
        self.pos_enc = PositionEmbeddingSine(self.dim_feat // 2, normalize=True)

        # global trajectory helper
        self.global_traj_helper = GlobalTrajHelper()

        self.linear_regress = cfg.get("linear_regress", True) 

        if self.task in ["motion", "video"]:
            # positional encoding
            if self.learnable_pe:
                self.m_pos_enc = torch.nn.Parameter(
                    torch.zeros(1, 1, self.num_tokens + 1, self.dim_feat)
                )
                trunc_normal_(self.m_pos_enc, std=0.02)
            else:
                self.m_pos_enc = None # placeholder

            # motion encoder
            self.m_token_embed = nn.Linear(self.dim_in, self.dim_feat)
            self.m_transformer = DSTFormer(cfg, self.dim_feat, self.mdepth)

            # canonical space trajectory embedding and regressor
            self.m_pose_regressor = nn.Linear(self.dim_feat, self.dim_out)
            self.m_traj_embed = nn.Linear(self.dim_cano_traj, self.dim_feat)
            if self.linear_regress: 
                self.m_traj_regressor = nn.Linear(self.dim_feat, self.dim_cano_traj)
                self.m_contact_regressor = nn.Linear(self.dim_feat, self.dim_contact)
            else:
                self.m_traj_regressor = Mlp(self.dim_feat, out_features=self.dim_cano_traj)
                self.m_contact_regressor = Mlp(self.dim_feat, out_features=self.dim_contact)

        if self.task in ["image", "video"]:
            # image encoder
            self.img_bbox_embed = nn.Linear(3, self.dim_feat)

            # image feature projection to transformer dimension
            self.img_embed = nn.Linear(self.dim_backbone_feat, self.dim_feat)
            self.img_pos_embed = PositionEmbeddingSine(self.dim_feat // 2, normalize=True)

            img_temporal = cfg.get("img_temporal", True)
            if img_temporal:
                self.img_transformer = DSTFormer(cfg, self.dim_feat, self.idepth)
            else:
                self.img_transformer = SpatialFormer(cfg, self.dim_feat, self.idepth)

            # coarse camera space trajectory regressor
            if self.linear_regress:
                self.img_traj_regressor = nn.Linear(self.dim_feat, self.dim_cam_traj)
            else:
                self.img_traj_regressor = Mlp(self.dim_feat, out_features=self.dim_cam_traj)

            # decoder
            # positional encoding
            if self.learnable_pe:
                self.d_pos_enc = torch.nn.Parameter(
                    torch.zeros(1, 1, self.num_tokens + 3, self.dim_feat)
                )
                trunc_normal_(self.d_pos_enc, std=0.02)
            else:
                self.d_pos_enc = None # placeholder

            # encode coarse camera space trajectory to feature space
            self.d_traj_embed = nn.Linear(self.dim_cam_traj, self.dim_feat)
            self.d_transformer = DSTFormer(cfg, self.dim_feat, self.ddepth)
            self.d_pose_regressor = nn.Linear(self.dim_feat, self.dim_out)

            # Fine camera space trajectory regressor
            if self.linear_regress:
                self.d_traj_regressor = nn.Linear(self.dim_feat, self.dim_cam_traj)
                self.d_contact_regressor = nn.Linear(self.dim_feat, self.dim_contact)
            else:
                self.d_traj_regressor = Mlp(self.dim_feat, out_features=self.dim_cam_traj)
                self.d_contact_regressor = Mlp(self.dim_feat, out_features=self.dim_contact) 

        self.apply(self._init_weights)

        self.load_from_ckpts()

        self.freeze()

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=0.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)

    def freeze(self):
        freeze_motion = self.cfg.get("freeze_motion", False)
        freeze_image = self.cfg.get("freeze_image", False)
        if freeze_motion:
            frozen_parts = [
                self.m_transformer,
                self.m_traj_embed,
                self.m_pose_regressor,
                self.m_traj_regressor,
                self.m_contact_regressor,
                self.m_token_embed,
                self.m_pos_enc,
            ]
            for part in frozen_parts:
                if part is None:
                    continue
                if isinstance(part, nn.Parameter):
                    part.requires_grad = False
                    continue
                for param in part.parameters():
                    param.requires_grad = False
                part.eval()
        if freeze_image:
            frozen_parts = [
                self.img_bbox_embed,
                self.img_embed,
                self.img_transformer, 
                self.img_traj_regressor
            ]
            for part in frozen_parts:
                if part is None:
                    continue
                if isinstance(part, nn.Parameter):
                    part.requires_grad = False
                    continue
                for param in part.parameters():
                    param.requires_grad = False
                part.eval()

        freeze_spatial = self.cfg.get("freeze_spatial", False)
        if freeze_spatial:
            frozen_parts = [blk.attn_s for blk in self.img_transformer.blocks_st] + \
                [blk.attn_s for blk in self.img_transformer.blocks_ts] + \
                [blk.attn_s for blk in self.d_transformer.blocks_st] + \
                [blk.attn_s for blk in self.d_transformer.blocks_ts]
            for part in frozen_parts:
                if isinstance(part, nn.Parameter):
                    part.requires_grad = False
                    continue
                for param in part.parameters():
                    param.requires_grad = False
                part.eval()
                

    def load_from_ckpts(self):
        motion_ckpt = self.cfg.get("motion_ckpt", None)
        image_ckpt = self.cfg.get("image_ckpt", None)

        motion_keys = [name for name, _ in self.named_parameters() if name.startswith("m_")]
        image_keys = [name for name, _ in self.named_parameters() if name.startswith("img_")]
        decode_keys = [name for name, _ in self.named_parameters() if name.startswith("d_")]

        self_sd = self.state_dict()
        if motion_ckpt is not None:
            # load motion encoder
            motion_ckpt = torch.load(motion_ckpt)
            motion_sd = motion_ckpt["state_dict"]
            motion_sd = {
                k.replace("mask_transformer.dst_former.", ""): v
                for k, v in motion_sd.items()
                if k.startswith("mask_transformer.dst_former.")
            }
            load_dict = {
                k: v
                for k, v in motion_sd.items()
                if k in motion_keys and self_sd[k].shape == v.shape
            }
            self.load_state_dict(load_dict, strict=False)

        if image_ckpt is not None:
            # load image encoder and decoder
            image_ckpt = torch.load(image_ckpt)
            image_sd = image_ckpt["state_dict"]
            image_sd = {
                k.replace("mask_transformer.dst_former.", ""): v
                for k, v in image_sd.items()
                if k.startswith("mask_transformer.dst_former.")
            }
            load_dict = {
                k: v
                for k, v in image_sd.items()
                if (k in image_keys or k in decode_keys) 
                and self_sd[k].shape == v.shape
            }
            self.load_state_dict(load_dict, strict=False)

    def motion_encode(self, tokens, cano_traj_noisy, motion_only=False):
        # embed to same dimension
        tokens = self.m_token_embed(tokens)
        cano_traj_input = self.m_traj_embed(cano_traj_noisy)
        cano_traj_input = cano_traj_input.unsqueeze(2)

        # NOTE: consider also mask the canonical trajectory tokens here

        motion_feat = torch.cat([tokens, cano_traj_input], dim=2)

        if self.learnable_pe:
            # learnable spatial PE
            motion_feat = motion_feat + self.m_pos_enc
            # remove sinusoidal temporal PE
            # motion_feat = motion_feat + self.pos_enc(
            #     *motion_feat.shape[:2], 1, device=motion_feat.device
            # )
        else:
            motion_feat = motion_feat + self.pos_enc(
                motion_feat.shape[0], 1, motion_feat.shape[2], device=motion_feat.device)

        motion_feat = self.m_transformer(motion_feat)

        local_pose_feat = motion_feat[:, :, : self.num_tokens, :]
        cano_traj_feat = motion_feat[:, :, -1:, :]
        cano_traj_clean = self.m_traj_regressor(cano_traj_feat.squeeze(2))

        if not motion_only:
            return local_pose_feat, cano_traj_feat, cano_traj_clean
        
        local_pose_logits = self.m_pose_regressor(local_pose_feat)
        local_pose_logits = einops.rearrange(local_pose_logits, "b f j c -> b c f j")
        contact_logits = self.m_contact_regressor(cano_traj_feat.squeeze(2))
        return local_pose_feat, cano_traj_feat, cano_traj_clean, local_pose_logits, contact_logits

    def image_encode(self, img_feat, bbox):
        bbox_feat = self.img_bbox_embed(bbox).unsqueeze(2)
        img_feat = self.img_embed(img_feat)

        # add 2D sinusoidal PE to image tokens
        H, W  = self.cfg.backbone_HW
        pos_embed = self.img_pos_embed(
            img_feat.shape[0], H, W, device=img_feat.device
        ).flatten(1, 2).unsqueeze(1)
        img_feat = img_feat + pos_embed
        img_feat = torch.cat([img_feat, bbox_feat], dim=2)

        # Transformer for image features
        img_feat = self.img_transformer(img_feat)

        img_feat, cam_traj_feat = img_feat[:, :, :-1, :], img_feat[:, :, -1:, :]
        coarse_cam_traj = self.img_traj_regressor(cam_traj_feat.squeeze(2))

        return img_feat, cam_traj_feat, coarse_cam_traj

    def parse_cam_traj_coarse(self, cam_traj_coarse_weak, bbox):
        cam_rot_coarse, cam_trans_coarse = self.global_traj_helper.cliff_transform(
            cam_traj_coarse_weak, bbox
        )
        cam_rot_6d_coarse = matrix_to_rotation_6d(cam_rot_coarse.unsqueeze(2))
        cam_traj_input = torch.cat(
            [cam_rot_6d_coarse, cam_trans_coarse], dim=-1
        )  # [B, F, 1, 9]
        cam_traj_feat = self.d_traj_embed(cam_traj_input)  # [B, F, 1, C]
        return (cam_rot_coarse, cam_trans_coarse), cam_traj_feat

    def decode(self, feat):
        # Decode token logits from motion + video features

        if self.learnable_pe:
            # learnable spatial PE
            feat[:, :, :self.num_tokens] = feat[:, :, :self.num_tokens] + self.d_pos_enc[:, :, :self.num_tokens]
            feat[:, :, self.num_tokens:-2] = feat[:, :, self.num_tokens:-2] + self.d_pos_enc[:, :, -3:-2]
            feat[:, :, -2:] = feat[:, :, -2:] + self.d_pos_enc[:, :, -2:]
        else:
            feat = feat + self.pos_enc(feat.shape[0], 1, feat.shape[2], device=feat.device)

        feat = self.d_transformer(feat)

        local_pose_feat = feat[:, :, : self.num_tokens, :]
        local_pose_logits = self.d_pose_regressor(local_pose_feat)
        local_pose_logits = einops.rearrange(local_pose_logits, "b f j c -> b c f j")

        cam_traj_feat = feat[:, :, -1, :]
        cam_traj = self.d_traj_regressor(cam_traj_feat)

        # transform rotation
        cam_rot_6d = cam_traj[..., :6]
        cam_rot = rotation_6d_to_matrix(cam_rot_6d)
        cam_trans = cam_traj[..., 6:].unsqueeze(2)

        cano_traj_feat = feat[:, :, -2, :]
        contact_logits = self.d_contact_regressor(cano_traj_feat)

        return local_pose_logits, contact_logits, (cam_rot, cam_trans)

    def forward(self, tokens, batch, cond_out=None, inf_cam_traj=None):
        """
        tokens: [B, F, J, C]
        img_feat: [B, F, J_i, C]
        """
        img_feat = batch.get("cond", None)
        B, F, J = tokens.shape[:3]

        if self.task == "motion":
            cano_traj_noisy = batch["cano_traj_noisy"]
            local_pose_feat, cano_traj_feat, cano_traj_clean, local_pose_logits, contact_logits = self.motion_encode(
                tokens, cano_traj_noisy, motion_only=True
            )
        elif self.task == "image":
            img_feat, _, cam_traj_coarse_weak = self.image_encode(img_feat, batch["bbox"])

            cam_traj_coarse, cam_traj_feat = self.parse_cam_traj_coarse(
                cam_traj_coarse_weak, batch["bbox"]
            ) 

            feat = torch.cat([
                # zeros for local_pose_feat 
                torch.zeros(B, F, J, self.dim_feat, device=tokens.device), 
                img_feat, 
                # zeros for cano_traj_feat
                torch.zeros(B, F, 1, self.dim_feat, device=tokens.device), 
                cam_traj_feat
            ], dim=2)
            local_pose_logits, _, cam_traj = self.decode(feat)
        elif self.task == "video":
            if cond_out is not None:
                cano_traj_noisy = cond_out["cano_traj_noisy"]
                local_pose_feat, _, cano_traj_feat, cano_traj_clean = self.motion_encode(
                    tokens, cano_traj_noisy
                )

                img_feat = torch.zeros_like(cond_out["img_feat"])
                cam_traj_feat = cond_out["cam_traj_feat"]
                cam_traj_coarse = cond_out["cam_traj_coarse"]
                feat = torch.cat([
                    local_pose_feat, img_feat, cano_traj_feat, cam_traj_feat
                ], dim=2)
            else:
                img_feat, _, cam_traj_coarse_weak = self.image_encode(img_feat, batch["bbox"])

                cam_traj_coarse, cam_traj_feat = self.parse_cam_traj_coarse(
                    cam_traj_coarse_weak, batch["bbox"]
                )

                if self.cfg.get("motion_drop", False):
                    feat = torch.cat([
                        # zeros for local_pose_feat 
                        torch.zeros(B, F, J, self.dim_feat, device=tokens.device), 
                        img_feat, 
                        # zeros for cano_traj_feat
                        torch.zeros(B, F, 1, self.dim_feat, device=tokens.device), 
                        cam_traj_feat
                    ], dim=2)
                    cano_traj_noisy = cano_traj_clean = batch["cano_traj_clean"] # gt values for zero loss
                else:
                    # canonicalize and normalize
                    if inf_cam_traj is not None:
                        cam_rot_noisy, cam_trans_noisy = inf_cam_traj
                    else:
                        cam_rot_noisy, cam_trans_noisy = cam_traj_coarse
                    _, cano_traj_noisy = self.global_traj_helper.get_cano_traj_repr(
                        cam_rot_noisy, cam_trans_noisy
                    )
                    cano_traj_noisy = cano_traj_noisy.detach()

                    local_pose_feat, cano_traj_feat, cano_traj_clean = self.motion_encode(
                        tokens, cano_traj_noisy
                    )

                    image_drop = self.cfg.get("image_drop", 0.)
                    assert 0.0 <= image_drop <= 1.0, "image_drop should be in [0, 1]"
                    if self.training and image_drop > 0. and np.random.rand() < image_drop:
                        # randomly drop image features
                        img_feat = torch.zeros_like(img_feat)
                    feat = torch.cat([
                        local_pose_feat, img_feat, cano_traj_feat, cam_traj_feat
                    ], dim=2)
            local_pose_logits, contact_logits, cam_traj = self.decode(feat)
        else:
            raise NotImplementedError(self.task)

        out = {
            "logits": local_pose_logits,
        }
        if self.task != "image":
            out.update(
                {
                    "cano_traj_noisy": cano_traj_noisy,
                    "cano_traj": cano_traj_clean,
                    "contact": contact_logits,
                } 
            )
        if self.task != "motion":
            out.update(
                {
                    "cam_traj_coarse_weak": cam_traj_coarse_weak,
                    "cam_traj_coarse": cam_traj_coarse,
                    "cam_traj": cam_traj,
                }
            )

        return out

    def inference(self, tokens, batch, last_output=None):
        if self.task == "motion":
            return self.inference_motion(tokens, batch, last_output)
        elif self.task == "image":
            return self(tokens, batch)
        elif self.task == "video":
            return self.inference_video(tokens, batch, last_output)
        else:
            raise NotImplementedError(self.task)

    def inference_motion(self, tokens, batch, last_output=None):
        """
        Inference mode on motion
        tokens: [B, F, J, C]
        img_feat: [B, F, J_i, C]
        """
        assert self.task == "motion", "Inference only supports video task"

        cano_traj_noisy = batch["cano_traj_noisy"]

        _, _, cano_traj_clean, local_pose_logits, contact_logits = self.motion_encode(
            tokens, cano_traj_noisy, motion_only=True
        )

        out = {
            "logits": local_pose_logits,
            "cano_traj_noisy": cano_traj_noisy,
            "cano_traj": cano_traj_clean,
            "contact": contact_logits,
        }
        return out

    def inference_video(self, tokens, batch, last_output=None):
        """
        Inference mode on video
        tokens: [B, F, J, C]
        img_feat: [B, F, J_i, C]
        """
        img_feat = batch.get("cond", None)
        B, F, J = tokens.shape[:3]
        assert self.task == "video", "Inference only supports video task"

        if last_output is None:
            # only compute image features at first iteration
            img_feat, _, cam_traj_coarse_weak = self.image_encode(img_feat, batch["bbox"])

            cam_traj_coarse, cam_traj_feat = self.parse_cam_traj_coarse(
                cam_traj_coarse_weak, batch["bbox"]
            )
            
            # canonicalize and normalize
            cam_rot_noisy, cam_trans_noisy = cam_traj_coarse
            _, cano_traj_noisy = self.global_traj_helper.get_cano_traj_repr(
                cam_rot_noisy, cam_trans_noisy
            )
            cano_traj_noisy = cano_traj_noisy.detach()
        else:
            # iteration > 0, use the canonicalized trajectory from last iteration prediction
            img_feat, cam_traj_feat, cam_traj_coarse, cam_traj_coarse_weak = (
                last_output["img_feat"],
                last_output["cam_traj_feat"],
                last_output["cam_traj_coarse"],
                last_output["cam_traj_coarse_weak"], 
            )

            cam_traj = last_output["cam_traj"]

            cam_rot_noisy, cam_trans_noisy = cam_traj
            _, cano_traj_noisy = self.global_traj_helper.get_cano_traj_repr(
                cam_rot_noisy, cam_trans_noisy
            )
            cano_traj_noisy = cano_traj_noisy.detach()

        
        if self.cfg.get("motion_drop", False):
            feat = torch.cat([
                # zeros for local_pose_feat 
                torch.zeros(B, F, J, self.dim_feat, device=tokens.device), 
                img_feat, 
                # zeros for cano_traj_feat
                torch.zeros(B, F, 1, self.dim_feat, device=tokens.device), 
                cam_traj_feat
            ], dim=2)
            cano_traj_noisy = cano_traj_clean = batch["cano_traj_clean"] # gt values for zero loss
        else:
            local_pose_feat, cano_traj_feat, cano_traj_clean = self.motion_encode( 
                tokens, cano_traj_noisy
            )

            feat = torch.cat(
                [local_pose_feat, img_feat, cano_traj_feat, cam_traj_feat], dim=2
            )

        local_pose_logits, contact_logits, cam_traj = self.decode(feat)

        out = {
            "logits": local_pose_logits,
            "cano_traj_noisy": cano_traj_noisy,
            "cano_traj": cano_traj_clean,
            "contact": contact_logits,
            "img_feat": img_feat,
            "cam_traj_feat": cam_traj_feat,
            "cam_traj_coarse_weak": cam_traj_coarse_weak,
            "cam_traj_coarse": cam_traj_coarse,
            "cam_traj": cam_traj,
        }
        return out